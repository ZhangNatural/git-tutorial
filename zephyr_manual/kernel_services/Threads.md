### 线程

本节介绍用于创建，调度和删除独立可执行的指令线程的内核服务。

* 生命周期

* 调度

* 自定义数据

* 系统线程

* Workqueue线程

* 配置选项

* API参考

### 生命周期

一个线程是一个内核对象用于那些太冗长或太复杂的而无法用ISR（中断服务处理,Interrupt Service Routines）来处理的应用程序处理事务。

#### 概念

应用程序可以定义任意数量的线程，每个线程由生成线程时分配的ID来引用。

一个线程有下列这些关键属性：

* 一个堆栈区域，

* 一个线程控制块

* 一个入口点函数

* 一个调度优先级

* 一组线程选项

* 一个启动延时

* 一个执行模式

#### 线程的创建

一个线程必须被创建之后才能被使用。内核不仅初始化线程控制块还初始化堆栈部分的一端。线程堆栈其余的部分通常保持未初始化状态。

指定启动延迟为K_NO_WAIT来指示内核启动线程立即执行。或者通过指定一个超时的值来指示线程延时执行——例如，允许线程使用的设备变得可用。

内核允许在线程开始执行之前取消延迟启动。 如果线程已经启动，则取消请求无效。 成功取消延迟启动的线程必须重新生成才能使用。

#### 线程的终止

一旦线程启动，它通常会永久执行。 但是，线程可以通过从其入口点函数返回来同步结束其执行。 这被称为终止。

终止的线程负责在返回之前释放它可能拥有的任何共享资源（例如互斥锁和动态分配的内存），因为内核不会自动回收它们。

*注: 内核目前没有就应用程序重新生成终止的线程的能力做出任何声明。*

#### 线程的中止

线程可以通过中止来异步结束其执行。 如果线程触发致命错误条件（例如解引用空指针），则内核会自动中止线程。

通过调用k_thread_abort（），一个线程可以被另一个线程（或自己）中止。但是，通常最好发信号通知线程优雅地终止自身，而不是中止它。

与线程终止一样，内核不会回收中止线程拥有的共享资源。

*注: 内核目前没有对应用程序重新生成中止线程的能力做出任何声明。*

#### 线程的暂停

如果线程挂起，可以在不确定的时间内阻止它执行。函数k_thread_suspend（）可用于挂起任何线程，包括调用线程。 挂起已挂起的线程没有其他影响。

暂停后，在另一个线程调用k_thread_resume（）以删除暂停之前，无法调度线程。

*注: 线程可以使用k_sleep（）阻止自己在指定的时间段内执行。 但是，这与挂起线程不同，因为睡眠线程在达到时间限制时会自动执行。*

#### 线程的选项

内核支持一小组线程选项，允许线程在特定情况下接受特殊处理。 在生成线程时指定与线程关联的选项集。

不需要任何线程选项的线程的选项值为零。 需要线程选项的线程使用名称指定它，如果需要多个选项，则将字符|作为分隔符（即使用按位OR运算符组合选项）。

支持以下线程选项：

* K_ESSENTIAL

此选项将线程标记为必要线程。 这指示内核将线程的终止或中止视为致命系统错误。

默认情况下，该线程不被视为必需线程。

* K_FP_REGS and K_SSE_REGS

这些特定于x86的选项表明该线程分别使用CPU的浮点寄存器和SSE寄存器。 这指示内核在调度线程时采取额外步骤来保存和恢复这些寄存器的内容。 （有关更多信息，请参阅浮点服务。）

默认情况下，内核在调度线程时不会尝试保存和恢复这些寄存器的内容。

* K_USER

如果启用了CONFIG_USERSPACE，则此线程将在用户模式下创建，并具有降低的权限。 请参阅用户模式。 否则这个标志什么都不做。

* K_INHERIT_PERMS

如果启用了CONFIG_USERSPACE，则此线程将继承父线程具有的所有内核对象权限，但父线程对象除外。 请参阅用户模式。

### 实现

#### 产生线程

通过定义其堆栈区域及其线程控制块，然后调用k_thread_create（）来生成线程。 必须使用K_THREAD_STACK_DEFINE定义堆栈区域，以确保它在内存中正确设置。

线程生成函数返回其线程id，可用于引用线程。

以下代码生成一个立即启动的线程。

	#define MY_STACK_SIZE 500
	#define MY_PRIORITY 5
	
	extern void my_entry_point(void *, void *, void *);
	
	K_THREAD_STACK_DEFINE(my_stack_area, MY_STACK_SIZE);
	struct k_thread my_thread_data;
	
	k_tid_t my_tid = k_thread_create(&my_thread_data, my_stack_area,
	                                 K_THREAD_STACK_SIZEOF(my_stack_area),
	                                 my_entry_point,
	                                 NULL, NULL, NULL,
	                                 MY_PRIORITY, 0, K_NO_WAIT);

或者，可以通过调用K_THREAD_DEFINE在*_编译时_*生成线程。 观察宏自动定义堆栈区域，控制块和线程id变量。

以下代码与上面的代码段具有相同的效果。

	#define MY_STACK_SIZE 500
	#define MY_PRIORITY 5
	
	extern void my_entry_point(void *, void *, void *);
	
	K_THREAD_DEFINE(my_tid, MY_STACK_SIZE,
	                my_entry_point, NULL, NULL, NULL,
	                MY_PRIORITY, 0, K_NO_WAIT);

#### 用户模式约束

这部分只适用于** CONFIG_USERSPACE **启用的情况，并且用户线程尝试去创建一个新的线程时。** k_thread_create（）** API仍被使用，但是一些附加的约束条件必须被满足，否则这个调用线程将被终止。

* 调用线程必须具有在子线程和堆栈参数上授予的权限; 两者都被内核跟踪为内核对象。

* 子线程和堆栈对象必须处于未初始化状态，即它当前未运行且堆栈存储器未使用。

* 传入的堆栈大小参数必须等于或小于声明它时堆栈对象的边界。

* 必须使用K_USER选项，因为用户线程只能创建其他用户线程。

* 不得使用K_ESSENTIAL选项，用户线程可能不被视为必需线程。

* 子线程的优先级必须是有效的优先级值，并且等于或低于父线程。

#### 删除权限

如果启用了CONFIG_USERSPACE，则以超级用户模式运行的线程可以使用k_thread_user_mode_enter（）API执行到用户模式的单向转换。 这是一个单向操作，它将复位并将线程的堆栈内存归零。 该主题将被标记为非必要。

#### 终止线程

线程通过从其入口点函数返回来终止自身。

以下代码说明了线程可以终止的方式。

	void my_entry_point(int unused1, int unused2, int unused3)
	{
	    while (1) {
	        ...
	        if (<some condition>) {
	            return; /* thread terminates from mid-entry point function */
	        }
	        ...
	    }
	
	    /* thread terminates at end of entry point function */
	}

如果启用了CONFIG_USERSPACE，则中止线程将另外将线程和堆栈对象标记为未初始化，以便可以重新使用它们。

#### 建议用途

使用线程处理无法在ISR中处理的处理。

使用单独的线程来处理可以并行执行的逻辑上不同的处理操作。

### 调度

内核基于优先级的调度程序允许应用程序的线程共享CPU。

#### 概念

调度程序确定允许在任何时间点执行哪个线程; 这个线程被称为当前线程。

每当调度程序更改当前线程的标识，或者当ISR取代当前线程的执行时，内核首先保存当前线程的CPU寄存器值。 当线程稍后恢复执行时，将恢复这些寄存器值。

#### 线程状态
































