### 架构移植指南

[原始内容出处](https://docs.zephyrproject.org/latest/guides/porting/arch.html#) 

需要一个体系结构端口才能使Zephyr在ISA或当前不支持的ABI上运行。

以下是Zephyr支持的ISA和ABI的示例：

* x86_32 ISA与System V ABI
* x86_32 ISA与IAMC U ABI
* 具有Thumb2指令集的ARMv7-M ISA和ARM嵌入式ABI（aeabi）
* ARCv2 ISA

有关Kconfig配置的信息，请参阅“电路板移植指南”中的“设置配置值”部分。 体系结构使用类似的Kconfig配置方案。 Kconfig  - 提示和最佳实践页面提供了一些有关编写Kconfig文件的一般建议和提示。

架构端口可以分为几个部分; 大部分是必需的，有些是可选的：

* 早期启动顺序：每个架构都有不同的步骤，当CPU退出复位（必需）时必须执行这些步骤。

* 中断和异常处理：每个体系结构以特定方式处理异步和未请求的事件（必需）。

* 线程上下文切换：Zephyr上下文切换依赖于ABI，每个ISA都有一组不同的寄存器来保存（必需）。

* 线程创建和终止：线程的初始堆栈帧是ABI和体系结构相关的，并且线程中止可能也是（必需的）。

* 设备驱动程序：通常，系统时钟计时器和中断控制器与架构相关联（一些是必需的，一些是可选的）。

* 实用程序库：出于性能原因，某些常见的内核API依赖于体系结构特定的实现（必需）。

* CPU空闲/电源管理：大多数架构都实现了使CPU进入休眠状态的指令（部分可选，很可能非常需要）。

* 故障管理：用于实现体系结构特定的调试帮助和处理线程中的致命错误（部分可选）。

* 链接器脚本和工具链：在构建系统和链接图像（需要）时，很可能需要特定于体系结构的详细信息。

#### 早期启动顺序

早期启动序列的目标是使系统从复位后的状态进入可以运行C代码的状态，从而实现公共内核初始化序列。 大多数情况下，只需要很少的步骤，而一些架构需要执行更多的工作。

所有架构的常见步骤：

* 设置初始堆栈。

* 如果运行XIP内核，请复制初始化数据

* 从ROM到RAM。

* 如果不使用ELF加载程序，则将BSS部分归零。

* 跳转到_Cstart（），早期的内核初始化

    * _Cstart（）负责将启动时运行的伪上下文切换到主线程。
    
必须采取的一些特定于体系结构的步骤示例：

* 如果在x86_32上以实模式给出控制，则切换到32位保护模式。

* 在x86_32上设置段寄存器以处理使它们处于未知或损坏状态的引导加载程序。

* 在Cortex-M3 / 4上初始化一个特定于板的看门狗。

* 将堆栈从MSP切换到Cortex-M上的PSP。

* 使用与调用Cortex-M上的_Swap（）以防止竞争条件不同的方法。

* 在ARCv2上设置FIRQ和常规IRQ处理。

#### 中断和异常处理

每种体系结构都以不同的方式定义中断和异常处理。

当设备想要向处理器发出信号，表示有一些工作需要代表它完成时，会引发中断。 当线程执行的操作不是由软件本身的串行流处理时，它会引发异常。 中断和异常都将控制传递给处理程序。 在中断的情况下，处理程序称为ISR。 处理程序执行异常或中断所需的工作。 对于中断，该工作是特定于设备的。 对于异常，它取决于异常，但通常核心内核本身负责提供处理程序。

除了处理程序本身执行的工作之外，内核还必须执行一些工作。 例如：

* 在将控制权交给处理程序之前：

    * 保存当前正在执行的上下文
    
    * 可能退出省电模式，包括唤醒设备。
    
    * 如果离开无空闲模式，则更新内核正常运行时间。
    
* 从处理程序获得控制权后：

    * 决定是否执行上下文切换。
    
    * 执行上下文切换时，恢复上下文切换的上下文。

这项工作在架构上在概念上是相同的，但细节完全不同：

* 寄存器保存和恢复。

* 处理器执行工作的指令。

* 异常的编号。

* 等等

因此，它需要一种特定于体系结构的实现，称为中断/异常存根。

另一个问题是内核将ISR的签名定义为：

	void (*isr)(void *parameter)

体系结构没有一致或本地的方法来处理ISR的参数。 因此，有两种常用的方法来处理参数。

* 使用一些体系结构定义的机制，在存根中强制参数值。 这在基于X86的体系结构中很常见。

* ISR的参数通过单独的表插入和跟踪，要求体系结构在运行时发现正在执行哪个中断。 为实际中断向量表的所有条目安装一个公共中断处理程序分离器，然后从单独的表中获取设备的ISR和参数。 这种方法通常通过CONFIG_GEN_ISR_TABLES实现在ARC和ARM体系结构中使用。 您可以通过查看x86中的_interrupt_enter（），ARM中的_IntExit（），ARM中的_isr_wrapper（）或arch / arc / core / isr_wrapper.S中ARC的完整实现说明来查找存根的示例。

每个架构还必须实现中断控制的原语：

* 锁定中断：irq_lock（），irq_unlock（）。

* 注册中断：IRQ_CONNECT（）。

* 如果可能，编程优先级irq_priority_set（）。

* 启用/禁用中断：irq_enable（），irq_disable（）。

*注：
IRQ_CONNECT是一个宏，它使用汇编器和/或链接器脚本技巧在构建时连接中断，从而节省了引导时间和文本大小。*

向量表应包含可能发生的每个中断和异常的处理程序。 处理程序可以像旋转循环一样简单。 但是，我们强烈建议处理程序至少打印一些调试信息。 该信息有助于确定在发生故障异常时出现的问题，例如被零除或无效的存储器访问，或者不期望的中断（伪中断）。 有关示例，请参阅arch / arm / core / fault.c中的ARM实现。

#### 线程上下文切换

多线程是拥有内核的基本目的。Zephyr支持两种类型的线程:抢占线程和协作线程。

编写体系结构端口时的两个关键概念如下：

* 协作线程的运行优先级高于可抢占的线程，并始终抢占它们。

* 在处理中断之后，如果协作线程被中断，内核总是返回运行该线程，因为它不是可抢占的。

上下文切换可能在以下几种情况下发生：

* 当线程执行阻塞操作时，例如获取当前不可用的信号量。

* 当可抢占线程通过释放阻塞它的对象来解除对优先级较高的线程的阻塞时。

* 当中断解除阻塞优先级高于当前正在执行的线程的线程时，如果当前正在执行的线程是可抢占的。

* 线程运行完成时。

* 当一个线程导致致命异常并从正在运行的线程中删除时。 例如，引用无效内存，

因此，上下文切换因此必须能够处理所有这些情况。

内核使下一个线程在“缓存”中运行，因此上下文切换代码只需从该缓存中获取以选择要运行的线程。

有两种类型的上下文切换：协作和抢占。

* 当线程故意将控件提供给另一个线程时，会发生协作上下文切换。 有两种情况会发生这种情况
    * 线程明确产生时。
    * 当线程尝试获取当前不可用的对象并且愿意等待对象变为可用时。
* 如果当前正在运行的线程是可抢占的，则因为ISR或线程导致调度比当前正在运行的线程更高优先级的线程的操作发生抢占上下文切换。 这种操作的一个例子是释放优先级较高的线程正在等待的对象。

注：
当其中一个是正在运行的线程时，控制永远不会从协作线程中获取。

通过让线程调用_Swap（）内核内部符号来完成协作上下文切换。 当调用_Swap时，内核逻辑知道必须发生上下文切换：_Swap不检查上下文切换是否必须发生。 相反，_Swap决定上下文切换到什么线程。当正在操作的对象不可用时，内核逻辑调用_Swap，以及一些线程产生/休眠原语。

注：
在x86和Nios2上，_Swap足够通用，架构足够灵活，可以在退出中断时调用_Swap以激发上下文切换。 这不应该作为规则，因为ARM Cortex-M或ARCv2端口都不这样做。

由于_Swap是协作的，因此来自ABI的调用者保存的寄存器已经在堆栈中。 无需将它们保存在k_thread结构中。

也可以抢先执行上下文切换。 这是在退出内核中断出口存根中的ISR时发生的：

* 调用处理程序后，在x86上使用_interrupt_enter。
* _IntExit在ARM上。
* ARCv2上的_firq_exit和_rirq_exit。

在这种情况下，只有当被中断的线程是可抢占的时，才能调用上下文切换，而不是当它是一个协作的线程时，并且只有当当前的中断没有嵌套时才能调用。

内核还具有“锁定调度程序”的概念。 这是一个类似于锁定中断的概念，但由于中断仍然可能发生，因此重量更轻。 如果一个线程锁定了调度程序，它是否暂时不可抢占。

因此，退出中断时调用上下文切换的决策逻辑很简单：

* 如果被中断的线程不可抢占，请不要调用它。

* 否则，从就绪队列中获取缓存的线程，并且：

    * 如果缓存的线程不是当前线程，则调用上下文切换。
    * 否则，不要调用它。

这很简单，但很关键：如果没有正确实现，内核将无法按预期运行，并且会遇到奇怪的崩溃，主要是由于堆栈损坏。

注：
如果运行仅有coop的系统，即如果CONFIG_NUM_PREEMPT_PRIORITIES为0，则不会发生抢先上下文切换。 在这种情况下，可以优化中断代码以不采取任何调度决策。

#### 线程创建和终止

要启动一个新线程，必须构造一个堆栈帧，以便上下文切换可以像从已经上下文切换的线程中弹出一个那样弹出它。 这将在特定于体系结构的_new_thread内部例程中实现。

线程入口点也不是直接调用的，即它不应该被设置为新线程的PC。 相反，它必须包装在_thread_entry中。 这意味着堆栈帧中的PC应设置为_thread_entry，并且线程入口点应作为第一个参数传递给_thread_entry。 具体情况取决于ABI。

对体系结构特定的线程终止实现的需求取决于体系结构。 有一个通用的实现，但它可能不适用于给定的体系结构。

具有特定于体系结构的线程终止实现所遇到的一个原因是，如果由于正常退出或由于异常而中止，则中止线程可能会有所不同。 ARM Cortex-M就是这种情况，如果线程触发致命异常，CPU必须退出处理程序模式，但如果线程正常退出其入口点函数则不行。

这意味着实现特定于体系结构的k_thread_abort（）版本，并根据体系结构的需要设置Kconfig选项CONFIG_ARCH_HAS_THREAD_ABORT（例如，参见arch / arm // core / cortex_m / Kconfig）。

#### 设备驱动程序

内核需要很少的硬件设备才能运行。 理论上，唯一需要的设备是中断控制器，因为内核可以在没有系统时钟的情况下运行。 在实践中，为了访问大多数（如果不是全部）健全性检查测试套件，还需要系统时钟。 由于这两者通常与架构相关联，因此它们是架构端口的一部分。

##### 中断控制器

中断控制器和跨架构的中断概念之间可能存在显着差异。

例如，x86具有IDT和不同中断控制器的概念。 虽然现代系统大多是在APIC上标准化的，但一些基于Quark的小型系统使用MVIC。 此外，IDT中断的位置决定了它的优先级。

另一方面，ARM Cortex-M将NVIC作为架构定义的一部分。 不需要与NVIC向量表分开的类似IDT的表。 表中的位置与IRQ的优先级无关：优先级是每个条目可编程的。

ARCv2的中断单元是体系结构定义的一部分，有点类似于NVIC。 但是，ARC将中断定义为在异常和中断号之间具有一对一映射（即异常1是IRQ1，设备IRQ从16开始），ARM使IRQ0等同于异常16（奇怪的是，异常1 可以看作是IRQ-15）。

所有这些差异意味着在中断控制器的架构之间可以共享很少（如果有的话）。

##### 系统时钟

x86具有APIC计时器和HPET作为其体系结构定义的一部分。 ARM Cortex-M具有SYSTICK异常。 最后，ARCv2具有timer0 / 1设备。

内核超时在系统时钟定时器驱动程序的中断处理程序的上下文中处理。

###### Tickless Idle

内核支持Tickless Idle。 Tickless Idle是这样一种概念，即当内核即将空闲并且最接近的超时到期超过某个阈值时，不会将系统时钟定时器中断传送到CPU。 当这种情况发生时，系统时钟将在未来重新编程，而不是定期打勾。 为此，系统时钟计时器驱动程序必须支持它。

Tickless Idle是可选的，但强烈建议实现低功耗。

内核内置了对Tickless Idle的支持。

系统时钟计时器驱动程序必须实现一些挂钩以支持Tickless Idle。 有关示例，请参阅现有驱动

需要调整中断入口存根（_interrupt_enter，_isr_wrapper）以处理退出的Tickless Idle。 请参阅现有体系结构的代码中的示例。

##### 串口控制台

还有一种设备几乎是架构端口的必要条件，因为它对于调试非常有用。它是一个简单的轮询，只输出，串行端口驱动程序发送控制台(printk, printf)输出。

它不是必需的，可以使用RAM控制台(CONFIG_RAM_CONSOLE)将所有输出发送到一个循环缓冲区，以便调试器读取。

#### 实用程序库

内核依赖于一些函数，这些函数可以用很少的指令实现，或者在现代处理器中以无锁方式实现。 因此，预期这些将作为架构端口的一部分来实现。

* 原子操作符。
    * 如果给定体系结构不存在指令，则存在一个通用版本，该版本围绕非原子操作封装irq_lock()或irq_unlock()。它是使用CONFIG_ATOMIC_OPERATIONS_C Kconfig选项配置的。
* Find-least-significant-bit-set和find-most-significant-bit-set。
    * 如果给定体系结构不存在指令，则始终可以将这些函数实现为通用C函数。
    
可以使用编译器内置函数来实现这些，但要小心它们使用所需的编译器障碍。

#### CPU空闲/电源管理

内核通过两个函数为CPU电源管理提供支持：k_cpu_idle（）和k_cpu_atomic_idle（）。

k_cpu_idle（）可以像调用解锁中断的体系结构的省电指令一样简单，例如在x86上的hlt，在ARM上的wfi或wfe，在ARC上休眠。 可以在上下文中的循环中调用此函数，该上下文不关心它是否在进入休眠之前被中断中断。 使用此功能时，基本上有两种情况：

* 在单线程系统中，在线程未在初始化之后用于执行实际工作的唯一线程中，即它在应用程序的持续时间内在循环中无效。

* 在空闲线程中。

另一方面，k_cpu_atomic_idle（）必须能够原子地重新启用中断并调用节能指令。 因此，它可以在实际应用程序代码中使用，也可以在单线程系统中使用。

通常，空闲CPU应留给空闲线程，但在某些非常特殊的情况下，应用程序可以使用这些API。

这两个函数必须存在于给定的体系结构中 但是，如果需要，实现可以简单地执行以下步骤：

* 解锁中断
* NOP

但是，强烈建议采用真正的实施方式。

#### 故障管理

每个体系结构都提供两个致命错误处理程序：

* _NanoFatalErrorHandler，由软件调用以获取不可恢复的错误。

* _SysFatalErrorHandler，它决定如何处理生成错误的线程，最有可能是通过终止它。

请参阅当前的体系结构实现示例。

#### 工具链和链接

必须将工具链支持添加到构建系统中。

include / toolchain / gcc.h中需要一些特定于体系结构的定义。 查看该文件中当前支持的体系结构的内容。

即使大多数部分可以从其他体系结构的链接描述文件派生，每个体系结构也需要自己的链接描述文件。 某些部分可能特定于新体系结构，例如ARM上的SCB部分和x86上的IDT部分。

##### 硬件堆栈保护

如果处于管理程序模式的线程溢出其堆栈，则此选项使用硬件功能生成致命错误。 这对于调试很有用，但由于某些原因，在发生这种情况之后，您无法可靠地对系统状态进行任何断言：

* 当溢出发生时，内核可能位于关键部分内，使重要的全局数据结构处于损坏状态。

* 对于使用保护存储区实现堆栈保护的系统，在硬件检测到这种情况之前，可能会过度保护并破坏相邻的数据结构。

要启用CONFIG_HW_STACK_PROTECTION功能，系统必须提供某种基于硬件的堆栈溢出保护，并启用CONFIG_ARCH_HAS_STACK_PROTECTION选项。

没有C API需要实现来支持堆栈保护，它完全在arch /代码中实现。 但是在大多数情况下（例如，如果需要定义保护区域），架构将需要在arch / cpu.h中声明其自己的K_THREAD_STACK宏版本：

* _ARCH_THREAD_STACK_DEFINE()
* _ARCH_THREAD_STACK_ARRAY_DEFINE()
* _ARCH_THREAD_STACK_MEMBER()
* _ARCH_THREAD_STACK_SIZEOF()

对于使用存储器保护单元（MPU）或存储器管理单元（MMU）实现堆栈保护的系统，通常通过在堆栈区域之前立即声明保护存储器区域来完成。

* 在MMU系统上，此保护区域是整个页面，其页表中的权限将在写入时生成错误。 需要在arch的_new_thread（）函数中配置此页面。

* 在MPU系统上，需要为线程堆栈保护区域保留一个MPU区域，其大小应该最小化。 应该在上下文切换上重新配置MPU中的区域，使得传入线程的保护区域不可写。

##### 用户模式线程

要支持用户模式线程，需要实现几个内核到arch的API，并且系统必须启用CONFIG_ARCH_HAS_USERSPACE选项。 有关更多详细信息，请参阅每个功能的文档：

* z_arch_buffer_validate（）用于测试当前线程是否具有对特定内存区域的访问权限

* z_arch_user_mode_enter（）将不可逆转地将主管线程丢弃到用户模式权限。 必须擦拭堆栈。

* z_arch_syscall_oops（）在无法验证系统调用参数时生成内核oops，这样oops似乎是从用户线程中调用系统调用的位置生成的

* z_arch_syscall_invoke0（）到z_arch_syscall_invoke6（）使用适当数量的参数调用系统调用，这些参数必须在权限提升期间通过寄存器传递。

* 如果CPU当前在用户模式下运行，则z_arch_is_user_context（）返回非零值

* z_arch_mem_domain_max_partitions_get（），表示内存域的最大区域数。 MMU系统具有无限量，MPU系统对此有限制。

* z_arch_mem_domain_partition_remove（）如果当前正在执行的线程是该域的一部分，则从内存域中删除分区。

* z_arch_mem_domain_destroy（）重置线程的内存域配置

除了实现这些API之外，还有一些其他任务：

* _new_thread（）需要在用户模式下使用K_USER生成线程

* 在上下文切换时，通过在内存管理硬件中进行适当的配置更改，应该将传出线程的堆栈内存标记为用户模式不可访问。传入线程的堆栈内存同样应标记为可访问。 这可以确保线程不会与其他线程堆栈混淆。

* 在上下文切换时，系统需要在传入和传出线程的内存域之间切换。

* 线程堆栈区域必须包含内核堆栈区域。 用户线程始终无法访问。 系统调用时将使用此堆栈。 对于所有线程，这应该是固定大小，并且必须足够大以处理任何系统调用。

* 需要建立软件中断或某种特权提升机制。 这与_arch_syscall_invoke宏的实现方式密切相关。 在系统调用时，需要在_k_syscall_table中查找相应的处理函数。 错误的系统调用ID应跳转到K_SYSCALL_BAD处理程序。 完成系统调用后，必须注意不要将任何寄存器状态泄漏回用户模式。

